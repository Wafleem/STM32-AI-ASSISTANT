-- PINS DATA
INSERT INTO pins VALUES ('VBAT', '', NULL, 1, 'S', 0, '', '[]', 'Battery backup supply for RTC and backup registers');
INSERT INTO pins VALUES ('PC13', 'C', 13, 2, 'I/O', 0, 'PC13', '[{"name":"GPIO","peripheral":null,"remap":false},{"name":"TAMPER-RTC","peripheral":"RTC","remap":false}]', 'Limited drive: max 3mA sink, max 2MHz speed, max 30pF load. Powered by backup domain power switch.');
INSERT INTO pins VALUES ('PC14', 'C', 14, 3, 'I/O', 0, 'PC14', '[{"name":"GPIO","peripheral":null,"remap":false},{"name":"OSC32_IN","peripheral":"RTC","remap":false}]', 'Limited drive: max 3mA sink, max 2MHz speed. Connect to 32.768kHz crystal for RTC, or use as GPIO.');
INSERT INTO pins VALUES ('PC15', 'C', 15, 4, 'I/O', 0, 'PC15', '[{"name":"GPIO","peripheral":null,"remap":false},{"name":"OSC32_OUT","peripheral":"RTC","remap":false}]', 'Limited drive: max 3mA sink, max 2MHz speed. Connect to 32.768kHz crystal for RTC, or use as GPIO.');
INSERT INTO pins VALUES ('OSC_IN', '', NULL, 5, 'I', 0, '', '[]', 'Main oscillator input (4-16MHz crystal or external clock)');
INSERT INTO pins VALUES ('OSC_OUT', '', NULL, 6, 'O', 0, '', '[]', 'Main oscillator output (connect to crystal)');
INSERT INTO pins VALUES ('NRST', '', NULL, 7, 'I/O', 0, '', '[]', 'Reset input (active LOW) with internal pull-up. Can also be configured as output.');
INSERT INTO pins VALUES ('VSSA', '', NULL, 8, 'S', 0, '', '[]', 'Analog ground reference for ADC and other analog blocks');
INSERT INTO pins VALUES ('VDDA', '', NULL, 9, 'S', 0, '', '[]', 'Analog power supply (2.4V to 3.6V). Also serves as VREF+ on LQFP48 package.');
INSERT INTO pins VALUES ('PA0', 'A', 0, 10, 'I/O', 0, 'PA0', '[{"name":"GPIO","peripheral":null,"remap":false},{"name":"WKUP","peripheral":"SYSTEM","remap":false},{"name":"USART2_CTS","peripheral":"USART2","remap":false},{"name":"ADC12_IN0","peripheral":"ADC","remap":false},{"name":"TIM2_CH1_ETR","peripheral":"TIM2","remap":false}]', 'WKUP function can wake device from Standby mode.');
INSERT INTO pins VALUES ('PA1', 'A', 1, 11, 'I/O', 0, 'PA1', '[{"name":"GPIO","peripheral":null,"remap":false},{"name":"USART2_RTS","peripheral":"USART2","remap":false},{"name":"ADC12_IN1","peripheral":"ADC","remap":false},{"name":"TIM2_CH2","peripheral":"TIM2","remap":false}]', '');
INSERT INTO pins VALUES ('PA2', 'A', 2, 12, 'I/O', 0, 'PA2', '[{"name":"GPIO","peripheral":null,"remap":false},{"name":"USART2_TX","peripheral":"USART2","remap":false},{"name":"ADC12_IN2","peripheral":"ADC","remap":false},{"name":"TIM2_CH3","peripheral":"TIM2","remap":false}]', '');
INSERT INTO pins VALUES ('PA3', 'A', 3, 13, 'I/O', 0, 'PA3', '[{"name":"GPIO","peripheral":null,"remap":false},{"name":"USART2_RX","peripheral":"USART2","remap":false},{"name":"ADC12_IN3","peripheral":"ADC","remap":false},{"name":"TIM2_CH4","peripheral":"TIM2","remap":false}]', '');
INSERT INTO pins VALUES ('PA4', 'A', 4, 14, 'I/O', 0, 'PA4', '[{"name":"GPIO","peripheral":null,"remap":false},{"name":"SPI1_NSS","peripheral":"SPI1","remap":false},{"name":"USART2_CK","peripheral":"USART2","remap":false},{"name":"ADC12_IN4","peripheral":"ADC","remap":false}]', '');
INSERT INTO pins VALUES ('PA5', 'A', 5, 15, 'I/O', 0, 'PA5', '[{"name":"GPIO","peripheral":null,"remap":false},{"name":"SPI1_SCK","peripheral":"SPI1","remap":false},{"name":"ADC12_IN5","peripheral":"ADC","remap":false}]', '');
INSERT INTO pins VALUES ('PA6', 'A', 6, 16, 'I/O', 0, 'PA6', '[{"name":"GPIO","peripheral":null,"remap":false},{"name":"SPI1_MISO","peripheral":"SPI1","remap":false},{"name":"ADC12_IN6","peripheral":"ADC","remap":false},{"name":"TIM3_CH1","peripheral":"TIM3","remap":false},{"name":"TIM1_BKIN","peripheral":"TIM1","remap":true}]', '');
INSERT INTO pins VALUES ('PA7', 'A', 7, 17, 'I/O', 0, 'PA7', '[{"name":"GPIO","peripheral":null,"remap":false},{"name":"SPI1_MOSI","peripheral":"SPI1","remap":false},{"name":"ADC12_IN7","peripheral":"ADC","remap":false},{"name":"TIM3_CH2","peripheral":"TIM3","remap":false},{"name":"TIM1_CH1N","peripheral":"TIM1","remap":true}]', '');
INSERT INTO pins VALUES ('PB0', 'B', 0, 18, 'I/O', 0, 'PB0', '[{"name":"GPIO","peripheral":null,"remap":false},{"name":"ADC12_IN8","peripheral":"ADC","remap":false},{"name":"TIM3_CH3","peripheral":"TIM3","remap":false},{"name":"TIM1_CH2N","peripheral":"TIM1","remap":true}]', '');
INSERT INTO pins VALUES ('PB1', 'B', 1, 19, 'I/O', 0, 'PB1', '[{"name":"GPIO","peripheral":null,"remap":false},{"name":"ADC12_IN9","peripheral":"ADC","remap":false},{"name":"TIM3_CH4","peripheral":"TIM3","remap":false},{"name":"TIM1_CH3N","peripheral":"TIM1","remap":true}]', '');
INSERT INTO pins VALUES ('PB2', 'B', 2, 20, 'I/O', 1, 'PB2-BOOT1', '[{"name":"GPIO","peripheral":null,"remap":false},{"name":"BOOT1","peripheral":"SYSTEM","remap":false}]', 'BOOT1 pin sampled at reset. Used with BOOT0 to select boot mode.');
INSERT INTO pins VALUES ('PB10', 'B', 10, 21, 'I/O', 1, 'PB10', '[{"name":"GPIO","peripheral":null,"remap":false},{"name":"I2C2_SCL","peripheral":"I2C2","remap":false},{"name":"USART3_TX","peripheral":"USART3","remap":false},{"name":"TIM2_CH3","peripheral":"TIM2","remap":true}]', 'Conflict: I2C2_SCL and USART3_TX cannot be used simultaneously.');
INSERT INTO pins VALUES ('PB11', 'B', 11, 22, 'I/O', 1, 'PB11', '[{"name":"GPIO","peripheral":null,"remap":false},{"name":"I2C2_SDA","peripheral":"I2C2","remap":false},{"name":"USART3_RX","peripheral":"USART3","remap":false},{"name":"TIM2_CH4","peripheral":"TIM2","remap":true}]', 'Conflict: I2C2_SDA and USART3_RX cannot be used simultaneously.');
INSERT INTO pins VALUES ('VSS_1', '', NULL, 23, 'S', 0, '', '[]', 'Digital ground');
INSERT INTO pins VALUES ('VDD_1', '', NULL, 24, 'S', 0, '', '[]', 'Digital power supply (2.0V to 3.6V)');
INSERT INTO pins VALUES ('PB12', 'B', 12, 25, 'I/O', 1, 'PB12', '[{"name":"GPIO","peripheral":null,"remap":false},{"name":"SPI2_NSS","peripheral":"SPI2","remap":false},{"name":"I2C2_SMBA","peripheral":"I2C2","remap":false},{"name":"USART3_CK","peripheral":"USART3","remap":false},{"name":"TIM1_BKIN","peripheral":"TIM1","remap":false}]', '');
INSERT INTO pins VALUES ('PB13', 'B', 13, 26, 'I/O', 1, 'PB13', '[{"name":"GPIO","peripheral":null,"remap":false},{"name":"SPI2_SCK","peripheral":"SPI2","remap":false},{"name":"USART3_CTS","peripheral":"USART3","remap":false},{"name":"TIM1_CH1N","peripheral":"TIM1","remap":false}]', '');
INSERT INTO pins VALUES ('PB14', 'B', 14, 27, 'I/O', 1, 'PB14', '[{"name":"GPIO","peripheral":null,"remap":false},{"name":"SPI2_MISO","peripheral":"SPI2","remap":false},{"name":"USART3_RTS","peripheral":"USART3","remap":false},{"name":"TIM1_CH2N","peripheral":"TIM1","remap":false}]', '');
INSERT INTO pins VALUES ('PB15', 'B', 15, 28, 'I/O', 1, 'PB15', '[{"name":"GPIO","peripheral":null,"remap":false},{"name":"SPI2_MOSI","peripheral":"SPI2","remap":false},{"name":"TIM1_CH3N","peripheral":"TIM1","remap":false}]', '');
INSERT INTO pins VALUES ('PA8', 'A', 8, 29, 'I/O', 1, 'PA8', '[{"name":"GPIO","peripheral":null,"remap":false},{"name":"USART1_CK","peripheral":"USART1","remap":false},{"name":"TIM1_CH1","peripheral":"TIM1","remap":false},{"name":"MCO","peripheral":"SYSTEM","remap":false}]', 'MCO (Microcontroller Clock Output) can output various internal clocks for external use.');
INSERT INTO pins VALUES ('PA9', 'A', 9, 30, 'I/O', 1, 'PA9', '[{"name":"GPIO","peripheral":null,"remap":false},{"name":"USART1_TX","peripheral":"USART1","remap":false},{"name":"TIM1_CH2","peripheral":"TIM1","remap":false}]', '');
INSERT INTO pins VALUES ('PA10', 'A', 10, 31, 'I/O', 1, 'PA10', '[{"name":"GPIO","peripheral":null,"remap":false},{"name":"USART1_RX","peripheral":"USART1","remap":false},{"name":"TIM1_CH3","peripheral":"TIM1","remap":false}]', '');
INSERT INTO pins VALUES ('PA11', 'A', 11, 32, 'I/O', 1, 'PA11', '[{"name":"GPIO","peripheral":null,"remap":false},{"name":"USART1_CTS","peripheral":"USART1","remap":false},{"name":"CANRX","peripheral":"CAN","remap":false},{"name":"USBDM","peripheral":"USB","remap":false},{"name":"TIM1_CH4","peripheral":"TIM1","remap":false}]', 'USB D- line. CAN default RX and USB share this pin.');
INSERT INTO pins VALUES ('PA12', 'A', 12, 33, 'I/O', 1, 'PA12', '[{"name":"GPIO","peripheral":null,"remap":false},{"name":"USART1_RTS","peripheral":"USART1","remap":false},{"name":"CANTX","peripheral":"CAN","remap":false},{"name":"USBDP","peripheral":"USB","remap":false},{"name":"TIM1_ETR","peripheral":"TIM1","remap":false}]', 'USB D+ line. CAN default TX and USB share this pin.');
INSERT INTO pins VALUES ('PA13', 'A', 13, 34, 'I/O', 1, 'JTMS-SWDIO', '[{"name":"JTMS","peripheral":"JTAG","remap":false},{"name":"SWDIO","peripheral":"SWD","remap":false},{"name":"GPIO","peripheral":null,"remap":true}]', 'Debug pin. Default function is JTMS/SWDIO. GPIO requires disabling debug interface via software.');
INSERT INTO pins VALUES ('VSS_2', '', NULL, 35, 'S', 0, '', '[]', 'Digital ground');
INSERT INTO pins VALUES ('VDD_2', '', NULL, 36, 'S', 0, '', '[]', 'Digital power supply (2.0V to 3.6V)');
INSERT INTO pins VALUES ('PA14', 'A', 14, 37, 'I/O', 1, 'JTCK-SWCLK', '[{"name":"JTCK","peripheral":"JTAG","remap":false},{"name":"SWCLK","peripheral":"SWD","remap":false},{"name":"GPIO","peripheral":null,"remap":true}]', 'Debug pin. Default function is JTCK/SWCLK. GPIO requires disabling debug interface via software.');
INSERT INTO pins VALUES ('PA15', 'A', 15, 38, 'I/O', 1, 'JTDI', '[{"name":"JTDI","peripheral":"JTAG","remap":false},{"name":"GPIO","peripheral":null,"remap":true},{"name":"TIM2_CH1_ETR","peripheral":"TIM2","remap":true},{"name":"SPI1_NSS","peripheral":"SPI1","remap":true}]', 'JTAG pin. Disabling JTAG (SWD-only mode) frees this pin for GPIO/SPI1_NSS/TIM2.');
INSERT INTO pins VALUES ('PB3', 'B', 3, 39, 'I/O', 1, 'JTDO', '[{"name":"JTDO","peripheral":"JTAG","remap":false},{"name":"TRACESWO","peripheral":"DEBUG","remap":false},{"name":"GPIO","peripheral":null,"remap":true},{"name":"TIM2_CH2","peripheral":"TIM2","remap":true},{"name":"SPI1_SCK","peripheral":"SPI1","remap":true}]', 'JTAG pin. Disabling JTAG (SWD-only mode) frees this pin for GPIO/SPI1_SCK/TIM2.');
INSERT INTO pins VALUES ('PB4', 'B', 4, 40, 'I/O', 1, 'JNTRST', '[{"name":"JNTRST","peripheral":"JTAG","remap":false},{"name":"GPIO","peripheral":null,"remap":true},{"name":"TIM3_CH1","peripheral":"TIM3","remap":true},{"name":"SPI1_MISO","peripheral":"SPI1","remap":true}]', 'JTAG reset pin. Disabling JTAG (SWD-only mode) frees this pin for GPIO/SPI1_MISO/TIM3.');
INSERT INTO pins VALUES ('PB5', 'B', 5, 41, 'I/O', 0, 'PB5', '[{"name":"GPIO","peripheral":null,"remap":false},{"name":"I2C1_SMBA","peripheral":"I2C1","remap":false},{"name":"TIM3_CH2","peripheral":"TIM3","remap":true},{"name":"SPI1_MOSI","peripheral":"SPI1","remap":true}]', 'NOT 5V tolerant (exception among Port B pins).');
INSERT INTO pins VALUES ('PB6', 'B', 6, 42, 'I/O', 1, 'PB6', '[{"name":"GPIO","peripheral":null,"remap":false},{"name":"I2C1_SCL","peripheral":"I2C1","remap":false},{"name":"TIM4_CH1","peripheral":"TIM4","remap":false},{"name":"USART1_TX","peripheral":"USART1","remap":true}]', 'I2C requires external pull-up resistors (typically 4.7K to 10K ohms).');
INSERT INTO pins VALUES ('PB7', 'B', 7, 43, 'I/O', 1, 'PB7', '[{"name":"GPIO","peripheral":null,"remap":false},{"name":"I2C1_SDA","peripheral":"I2C1","remap":false},{"name":"TIM4_CH2","peripheral":"TIM4","remap":false},{"name":"USART1_RX","peripheral":"USART1","remap":true}]', 'I2C requires external pull-up resistors (typically 4.7K to 10K ohms).');
INSERT INTO pins VALUES ('BOOT0', '', NULL, 44, 'I', 0, '', '[]', 'Boot mode selection input. Sampled at reset. LOW=boot from main Flash, HIGH=boot from System Memory (bootloader) or SRAM depending on BOOT1 (PB2).');
INSERT INTO pins VALUES ('PB8', 'B', 8, 45, 'I/O', 1, 'PB8', '[{"name":"GPIO","peripheral":null,"remap":false},{"name":"TIM4_CH3","peripheral":"TIM4","remap":false},{"name":"I2C1_SCL","peripheral":"I2C1","remap":true},{"name":"CANRX","peripheral":"CAN","remap":true}]', 'Alternate I2C1_SCL and CAN_RX location (remap required).');
INSERT INTO pins VALUES ('PB9', 'B', 9, 46, 'I/O', 1, 'PB9', '[{"name":"GPIO","peripheral":null,"remap":false},{"name":"TIM4_CH4","peripheral":"TIM4","remap":false},{"name":"I2C1_SDA","peripheral":"I2C1","remap":true},{"name":"CANTX","peripheral":"CAN","remap":true}]', 'Alternate I2C1_SDA and CAN_TX location (remap required).');
INSERT INTO pins VALUES ('VSS_3', '', NULL, 47, 'S', 0, '', '[]', 'Digital ground');
INSERT INTO pins VALUES ('VDD_3', '', NULL, 48, 'S', 0, '', '[]', 'Digital power supply (2.0V to 3.6V)');

-- KNOWLEDGE DATA
INSERT INTO knowledge VALUES ('chip_overview', 'general', '["overview","specs","specifications","what is","about"]', 'The STM32F103C8T6 is a medium-density performance line ARM Cortex-M3 microcontroller. It features 64KB Flash memory, 20KB SRAM, runs at up to 72MHz, and comes in a 48-pin LQFP package. It includes 2 ADCs (12-bit), 3 general-purpose 16-bit timers, 1 PWM timer, 2 I2C interfaces, 2 SPI interfaces, 3 USARTs, USB, CAN, and 37 GPIO pins.');
INSERT INTO knowledge VALUES ('memory_specs', 'memory', '["memory","flash","RAM","SRAM","storage","size"]', 'The STM32F103C8T6 has 64KB of Flash memory for program storage and 20KB of SRAM for data. The Flash memory is located at address 0x08000000 and SRAM at 0x20000000. The memory is organized in Little Endian format. Flash can be programmed in 16-bit half-words and has a typical endurance of 10,000 write/erase cycles.');
INSERT INTO knowledge VALUES ('clock_sources', 'clock', '["clock","oscillator","crystal","HSE","HSI","frequency","MHz","speed"]', 'The STM32F103C8T6 has multiple clock sources. The HSI (High Speed Internal) is an 8MHz factory-calibrated RC oscillator. The HSE (High Speed External) supports 4-16MHz crystals. The LSI is a 40kHz internal RC for watchdog/RTC. The LSE is 32.768kHz for RTC. The maximum system clock (SYSCLK) is 72MHz, achieved by using PLL multiplication of the HSE or HSI/2.');
INSERT INTO knowledge VALUES ('clock_configuration', 'clock', '["PLL","configure","setup","72MHz","maximum speed","clock tree"]', 'To achieve maximum 72MHz speed: Use an 8MHz external crystal on HSE, enable the PLL with a multiplication factor of 9 (8MHz x 9 = 72MHz). The AHB bus runs at SYSCLK speed (72MHz max). APB1 is limited to 36MHz max (use prescaler /2 when SYSCLK is 72MHz). APB2 runs at full SYSCLK speed. Flash wait states must be configured: 0 wait states for 0-24MHz, 1 wait state for 24-48MHz, 2 wait states for 48-72MHz.');
INSERT INTO knowledge VALUES ('bus_architecture', 'architecture', '["bus","APB1","APB2","AHB","peripheral","speed"]', 'The STM32F103 uses a Harvard architecture with separate instruction and data buses. The AHB (Advanced High-performance Bus) connects the core, DMA, and memory at up to 72MHz. Two APB buses connect peripherals: APB2 runs at full speed (72MHz) and connects fast peripherals like ADC, SPI1, USART1, TIM1, and GPIO. APB1 is limited to 36MHz and connects slower peripherals like I2C, SPI2, USART2/3, TIM2-4.');
INSERT INTO knowledge VALUES ('gpio_modes', 'GPIO', '["GPIO","mode","input","output","push-pull","open-drain","configure"]', 'GPIO pins can be configured in multiple modes: Input (floating, pull-up, pull-down, or analog), Output (push-pull or open-drain), and Alternate Function (push-pull or open-drain). Output speeds are 2MHz, 10MHz, or 50MHz. After reset, all GPIO pins are in Input Floating mode except JTAG pins (PA13/PA14/PA15/PB3/PB4) which default to their debug functions. Each pin has weak internal pull-up (~40K) and pull-down resistors.');
INSERT INTO knowledge VALUES ('gpio_5v_tolerance', 'GPIO', '["5V","tolerant","voltage","FT","input","level"]', 'Pins marked ''FT'' (Five-volt Tolerant) can accept up to 5.5V input when configured as input or open-drain output. On the STM32F103C8T6: PA8-PA15 are 5V tolerant, PB2-PB4 and PB6-PB15 are 5V tolerant (except PB5), PA0-PA7 are NOT 5V tolerant (they are ADC pins), PB0-PB1 are NOT 5V tolerant (ADC pins), PC13-PC15 are NOT 5V tolerant. Never apply 5V to non-FT pins or when pin is configured as push-pull output.');
INSERT INTO knowledge VALUES ('gpio_current', 'GPIO', '["current","mA","drive","LED","sink","source"]', 'Each GPIO pin can sink or source up to 25mA (absolute maximum), but 8mA is recommended for reliable operation. The total current for all GPIO pins combined must not exceed 150mA. PC13-PC15 are special: they''re powered through a switch limited to 3mA total, can only operate at 2MHz speed, and should not be used to drive loads like LEDs. For LED driving on other pins, use a series resistor to limit current.');
INSERT INTO knowledge VALUES ('jtag_swd_pins', 'GPIO', '["JTAG","SWD","debug","PA13","PA14","PA15","PB3","PB4","programming"]', 'After reset, PA13/PA14/PA15/PB3/PB4 are configured for JTAG debugging. PA13 is SWDIO, PA14 is SWCLK (these are needed for SWD programming). To use PA15, PB3, PB4 as GPIO or for SPI1 remap, you must disable JTAG via the AFIO_MAPR register (keeping SWD enabled). If you disable both JTAG and SWD by using PA13/PA14 as GPIO, you can only reprogram the chip using BOOT0 pin to enter bootloader mode.');
INSERT INTO knowledge VALUES ('adc_overview', 'ADC', '["ADC","analog","digital","convert","resolution","bits"]', 'The STM32F103C8T6 has two 12-bit ADCs (ADC1 and ADC2) with up to 10 external input channels. Resolution is 12 bits (0-4095). Input voltage range is 0V to VREF+ (typically 3.3V). Conversion time is 1┬╡s at 56MHz ADC clock. The ADC can operate in single, continuous, scan, or discontinuous modes. It supports DMA for automatic data transfer. There are also two internal channels: temperature sensor and internal reference voltage.');
INSERT INTO knowledge VALUES ('adc_channels', 'ADC', '["ADC","channel","pin","input","IN0","IN1"]', 'ADC channels on STM32F103C8T6: IN0=PA0, IN1=PA1, IN2=PA2, IN3=PA3, IN4=PA4, IN5=PA5, IN6=PA6, IN7=PA7, IN8=PB0, IN9=PB1. Internal channels: IN16=Temperature sensor, IN17=VREFINT (internal 1.2V reference). All external ADC pins are NOT 5V tolerant. The ADC input impedance is about 12k╬⌐, so source impedance should be low (under 10k╬⌐) for accurate readings.');
INSERT INTO knowledge VALUES ('adc_clock', 'ADC', '["ADC","clock","prescaler","speed","sample"]', 'ADC clock is derived from APB2 clock (PCLK2) via prescaler. Maximum ADC clock is 14MHz. With 72MHz SYSCLK, use prescaler of 6 to get 12MHz ADC clock. Conversion time = sampling time + 12.5 ADC cycles. Minimum sampling time is 1.5 cycles. Total minimum conversion time at 14MHz = (1.5 + 12.5) / 14MHz = 1┬╡s. For high-impedance sources, increase sampling time up to 239.5 cycles.');
INSERT INTO knowledge VALUES ('i2c_overview', 'I2C', '["I2C","interface","bus","two-wire","serial"]', 'The STM32F103C8T6 has two I2C interfaces (I2C1 and I2C2) supporting Standard mode (100kHz) and Fast mode (400kHz). Features include 7-bit and 10-bit addressing, multi-master capability, DMA support, and SMBus/PMBus compatibility. I2C is a two-wire interface using SDA (data) and SCL (clock) lines, both requiring external pull-up resistors.');
INSERT INTO knowledge VALUES ('i2c_pins', 'I2C', '["I2C","pin","SDA","SCL","PB6","PB7","PB10","PB11","remap"]', 'I2C1 default pins: SCL=PB6, SDA=PB7. I2C1 can be remapped to: SCL=PB8, SDA=PB9. I2C2 pins (no remap available): SCL=PB10, SDA=PB11. Note that I2C2 pins conflict with USART3 (PB10=USART3_TX, PB11=USART3_RX) - you cannot use both I2C2 and USART3 simultaneously. I2C1 default pins also share with TIM4 CH1/CH2.');
INSERT INTO knowledge VALUES ('i2c_pullups', 'I2C', '["I2C","pull-up","resistor","external","value","4.7K"]', 'I2C requires external pull-up resistors on SDA and SCL lines. The internal pull-ups (~40k╬⌐) are too weak for reliable I2C communication. Recommended values: 4.7k╬⌐ for 100kHz Standard mode, 2.2k╬⌐-3.3k╬⌐ for 400kHz Fast mode. Lower resistance allows faster rise times but increases power consumption. Pull-ups connect between the I2C line and VDD (3.3V). Many sensor breakout boards include pull-ups - check before adding your own to avoid too-low resistance.');
INSERT INTO knowledge VALUES ('spi_overview', 'SPI', '["SPI","interface","serial","peripheral"]', 'The STM32F103C8T6 has two SPI interfaces (SPI1 and SPI2). SPI1 is on APB2 (up to 18Mbit/s at 72MHz). SPI2 is on APB1 (up to 18Mbit/s at 36MHz). Features include full-duplex synchronous transfer, 8 or 16-bit data frame, master or slave mode, hardware CRC calculation, and DMA capability. SPI uses 4 signals: SCK (clock), MOSI (Master Out Slave In), MISO (Master In Slave Out), and NSS (slave select).');
INSERT INTO knowledge VALUES ('spi_pins', 'SPI', '["SPI","pin","SCK","MOSI","MISO","NSS","remap"]', 'SPI1 default pins: SCK=PA5, MISO=PA6, MOSI=PA7, NSS=PA4. SPI1 remap pins: SCK=PB3, MISO=PB4, MOSI=PB5, NSS=PA15. Using SPI1 remap requires disabling JTAG (PB3/PB4 are JTAG pins). SPI2 pins (no remap): SCK=PB13, MISO=PB14, MOSI=PB15, NSS=PB12. The NSS pin can be managed by hardware or software; software NSS (using any GPIO) is more flexible.');
INSERT INTO knowledge VALUES ('spi_clock', 'SPI', '["SPI","clock","speed","baud","prescaler","CPOL","CPHA"]', 'SPI clock is derived from the peripheral bus clock via prescaler (2, 4, 8, 16, 32, 64, 128, or 256). SPI1 max speed: 72MHz/2 = 36MHz as master. SPI2 max speed: 36MHz/2 = 18MHz as master. Clock polarity (CPOL) and phase (CPHA) are configurable for compatibility with different slave devices. Mode 0: CPOL=0, CPHA=0 (clock idle low, sample on rising edge). Mode 3: CPOL=1, CPHA=1 (clock idle high, sample on falling edge).');
INSERT INTO knowledge VALUES ('usart_overview', 'USART', '["USART","UART","serial","RS232","communication"]', 'The STM32F103C8T6 has three USARTs. USART1 is on APB2 (72MHz), supporting up to 4.5Mbit/s. USART2 and USART3 are on APB1 (36MHz). All support full-duplex asynchronous communication, synchronous mode, LIN, IrDA, and Smartcard protocols. Features include programmable baud rate, 8 or 9-bit data, 1 or 2 stop bits, parity control, DMA support, and hardware flow control (CTS/RTS).');
INSERT INTO knowledge VALUES ('usart_pins', 'USART', '["USART","UART","pin","TX","RX","remap"]', 'USART1 default: TX=PA9, RX=PA10. USART1 remap: TX=PB6, RX=PB7. USART2 (no remap on 48-pin package): TX=PA2, RX=PA3. USART3 default: TX=PB10, RX=PB11. Note: USART3 pins conflict with I2C2. For basic UART communication, you only need TX and RX pins. Connect TX of one device to RX of another, and vice versa. For RS232 level conversion, use a MAX232 or similar level shifter.');
INSERT INTO knowledge VALUES ('usart_baud_rate', 'USART', '["USART","UART","baud","rate","speed","115200"]', 'USART baud rate is calculated from the peripheral clock using a fractional divider. Common baud rates: 9600, 19200, 38400, 57600, 115200, 230400, 460800, 921600. USART1 max is about 4.5Mbit/s at 72MHz. For accurate baud rates, the peripheral clock should be evenly divisible. At 72MHz, 115200 baud works well. The BRR register contains a 12-bit mantissa and 4-bit fraction for precise baud generation.');
INSERT INTO knowledge VALUES ('timer_overview', 'Timer', '["timer","TIM","PWM","counter","pulse"]', 'STM32F103C8T6 has 4 timers. TIM1 is an advanced 16-bit timer with complementary outputs, dead-time, and break input for motor control. TIM2, TIM3, TIM4 are general-purpose 16-bit timers with 4 capture/compare channels each. All timers support PWM output, input capture, output compare, encoder interface, and can trigger DMA/interrupts. Timer clock is 72MHz when APB prescaler is >1 (timers get 2x the APB clock).');
INSERT INTO knowledge VALUES ('timer_pwm', 'Timer', '["PWM","pulse","width","modulation","duty","frequency"]', 'To generate PWM: Set timer period (ARR register) to define frequency: PWM_freq = Timer_clock / (PSC+1) / (ARR+1). Set capture/compare value (CCR) to define duty cycle: Duty = CCR / ARR ├ù 100%. Example for 1kHz PWM at 72MHz timer clock: PSC=71, ARR=999 gives exactly 1kHz. CCR=500 gives 50% duty cycle. PWM resolution depends on ARR value - higher ARR means finer duty cycle control but lower maximum frequency.');
INSERT INTO knowledge VALUES ('usb_overview', 'USB', '["USB","interface","device"]', 'The STM32F103C8T6 has a USB 2.0 Full-Speed (12Mbit/s) device interface. It supports control, bulk, interrupt, and isochronous transfers. USB uses pins PA11 (D-) and PA12 (D+). These pins are shared with CAN - you cannot use USB and CAN default pins simultaneously. For USB, the PLL must output 48MHz or 72MHz (USB prescaler divides by 1 or 1.5). A 1.5k╬⌐ pull-up on D+ is required (some boards have this built-in).');
INSERT INTO knowledge VALUES ('can_overview', 'CAN', '["CAN","bus","automotive","controller","area","network"]', 'The STM32F103C8T6 has one CAN 2.0B controller supporting 1Mbit/s. CAN default pins: RX=PA11, TX=PA12 (shared with USB). CAN remap: RX=PB8, TX=PB9. CAN requires an external transceiver (like MCP2551 or SN65HVD230) to convert logic levels to CAN bus differential signals. The CAN controller has 3 transmit and 2 receive mailboxes with 14 configurable filter banks.');
INSERT INTO knowledge VALUES ('dma_overview', 'DMA', '["DMA","direct","memory","access","transfer"]', 'The STM32F103C8T6 has a 7-channel DMA controller (DMA1). DMA allows memory-to-memory, peripheral-to-memory, and memory-to-peripheral transfers without CPU intervention. Each channel has configurable priority and supports circular mode for continuous transfers. DMA is useful for high-speed ADC sampling, UART/SPI buffering, and reducing CPU load. Channels are assigned to specific peripherals (e.g., DMA1_CH1 for ADC1).');
INSERT INTO knowledge VALUES ('boot_modes', 'Boot', '["boot","BOOT0","BOOT1","bootloader","flash","programming"]', 'Boot mode is selected by BOOT0 pin and BOOT1 (PB2) sampled at reset. BOOT0=0 (any BOOT1): Boot from main Flash at 0x08000000 - normal operation. BOOT0=1, BOOT1=0: Boot from System Memory at 0x1FFFF000 - built-in bootloader for UART/USB programming. BOOT0=1, BOOT1=1: Boot from SRAM at 0x20000000 - for debugging. To enter bootloader: Set BOOT0 high, keep BOOT1 low, reset the chip. The bootloader supports programming via USART1 (PA9/PA10).');
INSERT INTO knowledge VALUES ('power_supply', 'Power', '["power","voltage","VDD","VDDA","supply","3.3V"]', 'Operating voltage range: VDD = 2.0V to 3.6V, typical 3.3V. VDDA (analog supply) must be 2.4V to 3.6V and equal to or higher than VDD. Power consumption: ~36mA at 72MHz in Run mode, down to 2┬╡A in Standby mode. The chip has internal voltage regulator. For stable operation, provide adequate decoupling capacitors: 100nF ceramic on each VDD pin, 4.7┬╡F + 100nF on VDDA, 100nF on VBAT.');
INSERT INTO knowledge VALUES ('reset_circuit', 'Reset', '["reset","NRST","power-on","circuit"]', 'The NRST pin is active-low reset input with internal pull-up. Reset sources: external reset (NRST pin low), power-on/power-down reset, watchdog reset, software reset, low-power mode reset. Minimum reset pulse width is 20┬╡s. A simple reset circuit: 100nF capacitor from NRST to GND with optional 10K resistor to VDD. For noise immunity in industrial applications, add a reset supervisor IC.');
INSERT INTO knowledge VALUES ('watchdog', 'Watchdog', '["watchdog","IWDG","WWDG","timeout","reset"]', 'Two watchdog timers are available. The Independent Watchdog (IWDG) uses the 40kHz LSI clock, provides timeout from 100┬╡s to 26 seconds, and cannot be disabled once started. The Window Watchdog (WWDG) uses APB1 clock, must be refreshed within a timing window (not too early, not too late), and generates an early warning interrupt. Use IWDG for reliability; WWDG for detecting code timing issues.');
INSERT INTO knowledge VALUES ('low_power', 'Power', '["sleep","stop","standby","low power","wake"]', 'Three low-power modes: Sleep mode stops CPU but peripherals run (~14mA at 72MHz, HSI on). Stop mode stops all clocks but retains SRAM (~20┬╡A, all clocks off). Standby mode is lowest power (~2┬╡A) but loses SRAM content. Wake-up from Sleep: any interrupt. Wake-up from Stop: EXTI line, RTC alarm. Wake-up from Standby: WKUP pin (PA0), RTC alarm, NRST, IWDG. After Stop/Standby, HSI is selected as clock source.');
INSERT INTO knowledge VALUES ('rtc', 'RTC', '["RTC","real-time","clock","calendar","backup"]', 'The RTC provides a seconds counter (not calendar - software must convert). Clock sources: LSE (32.768kHz crystal on PC14/PC15), LSI (~40kHz), or HSE/128. LSE gives best accuracy. RTC continues running in Stop and Standby modes if VBAT is supplied. RTC alarm can wake the chip from low-power modes. The 20-byte backup registers also remain powered by VBAT. For battery backup, connect a 3V coin cell to VBAT pin.');
INSERT INTO knowledge VALUES ('interrupts_nvic', 'Interrupts', '["interrupt","NVIC","priority","IRQ","handler"]', 'The Cortex-M3 NVIC supports 43 maskable interrupt channels with 16 priority levels (4 bits). Priority grouping allows splitting into preemption and sub-priority. Lower number = higher priority. Common interrupts: EXTI0-4 (individual GPIO), EXTI9_5 and EXTI15_10 (grouped GPIO), TIM1-4, USART1-3, SPI1-2, I2C1-2, ADC1-2, DMA1 channels. Use __enable_irq() and __disable_irq() for global interrupt control.');
INSERT INTO knowledge VALUES ('exti', 'Interrupts', '["EXTI","external","interrupt","GPIO","edge","trigger"]', 'External interrupts (EXTI) can be triggered by any GPIO pin. Each EXTI line (0-15) can be connected to the corresponding pin number of any port (e.g., EXTI0 can be PA0, PB0, or PC0, but not multiple simultaneously). Trigger on rising edge, falling edge, or both. EXTI lines 0-4 have dedicated IRQ handlers; 5-9 share one handler; 10-15 share another. Configure via AFIO_EXTICR registers and EXTI registers.');
INSERT INTO knowledge VALUES ('flash_programming', 'Flash', '["flash","program","write","erase","unlock"]', 'Flash programming: First unlock with key sequence (KEY1=0x45670123, KEY2=0xCDEF89AB). Erase before writing (sets all bits to 1). Page erase takes ~20ms. Programming is 16-bit half-word at a time. Write takes ~20┬╡s per half-word. Lock after programming for protection. Mass erase erases entire Flash. Option bytes control read/write protection and watchdog configuration. Be careful: erasing or corrupting Flash near 0x08000000 can brick the chip.');
INSERT INTO knowledge VALUES ('common_mistakes', 'Troubleshooting', '["problem","mistake","error","not working","debug","troubleshoot"]', 'Common STM32 mistakes: 1) Forgetting to enable peripheral clock (RCC_APBxENR). 2) Not configuring GPIO alternate function mode. 3) Missing I2C pull-ups or using internal pull-ups (too weak). 4) Applying 5V to non-FT pins. 5) JTAG pins not freed for GPIO use. 6) Wrong Flash wait states for clock speed. 7) APB1 running above 36MHz. 8) Incorrect baud rate calculation. 9) Floating unused inputs causing excess current. 10) BOOT0 floating or pulled high, entering bootloader instead of running Flash code.');
INSERT INTO knowledge VALUES ('development_tools', 'Development', '["tool","IDE","program","debug","ST-Link","development"]', 'Development tools for STM32: IDEs include STM32CubeIDE (free, official), Keil MDK, IAR EWARM, PlatformIO with VSCode. Programming/debugging via ST-Link (SWD interface), J-Link, or UART bootloader. STM32CubeMX generates initialization code. Libraries: HAL (Hardware Abstraction Layer) for portability, or LL (Low-Level) for performance. CMSIS provides core peripheral access. OpenOCD supports ST-Link for open-source toolchains.');
INSERT INTO knowledge VALUES ('pin_conflicts_summary', 'Conflicts', '["conflict","share","cannot","both","same time"]', 'Key pin conflicts on STM32F103C8T6: PA11/PA12 shared by USB, CAN, USART1_CTS/RTS, TIM1. PB10/PB11 shared by I2C2 and USART3 - cannot use both. PB6/PB7 shared by I2C1 and TIM4 CH1/CH2. PA13/PA14 are SWD debug pins - using as GPIO disables debugging. PA15/PB3/PB4 are JTAG pins - must disable JTAG to use for SPI1 remap or GPIO. PA5/PA6/PA7 shared between SPI1 and ADC channels.');
INSERT INTO knowledge VALUES ('sensor_wiring_mpu6050', 'Sensors', '["MPU6050","GY-521","accelerometer","gyroscope","IMU","wire","connect"]', 'MPU6050/GY-521 wiring to STM32F103C8T6: VCCΓåÆ3.3V, GNDΓåÆGND, SCLΓåÆPB6 (I2C1_SCL), SDAΓåÆPB7 (I2C1_SDA). Optional: INTΓåÆany GPIO for interrupt, AD0ΓåÆGND for address 0x68 or VCC for 0x69. Most GY-521 modules have built-in pull-ups. If using I2C2: SCLΓåÆPB10, SDAΓåÆPB11. Configure I2C for 400kHz. The MPU6050 is 3.3V compatible; do not power from 5V if using 3.3V logic.');
INSERT INTO knowledge VALUES ('sensor_wiring_spi_generic', 'Sensors', '["SPI","sensor","wire","connect","SD","card","display"]', 'Generic SPI device wiring: SCKΓåÆPA5 (SPI1_SCK), MISOΓåÆPA6 (SPI1_MISO), MOSIΓåÆPA7 (SPI1_MOSI), CSΓåÆany GPIO (e.g., PA4). For SD card modules, add 10K pull-up on MISO. Most SPI devices are active-low chip select. If using SPI2: SCKΓåÆPB13, MISOΓåÆPB14, MOSIΓåÆPB15, CSΓåÆany GPIO. For 3.3V-only devices, do not connect to 5V signals. Level shifter needed if interfacing with 5V SPI devices.');
INSERT INTO knowledge VALUES ('sensor_wiring_uart_gps', 'Sensors', '["GPS","UART","serial","wire","connect","NEO"]', 'GPS module (e.g., NEO-6M) wiring: VCCΓåÆ3.3V (or 5V if module has regulator), GNDΓåÆGND, TX (GPS)ΓåÆPA10 (USART1_RX), RX (GPS)ΓåÆPA9 (USART1_TX). Note TX connects to RX and vice versa. Default baud rate usually 9600. GPS modules output NMEA sentences continuously. If using USART2: TXΓåÆPA3, RXΓåÆPA2. Some GPS modules are 3.3V only - check before connecting to 5V.');
INSERT INTO knowledge VALUES ('ethernet_overview', 'Ethernet', '["ethernet","network","MAC","PHY","connectivity"]', 'Note: The STM32F103C8T6 does NOT have Ethernet capability. Ethernet is only available on STM32F107 ''connectivity line'' devices, not the STM32F103 ''performance line''. For network connectivity with STM32F103, use external modules like W5500 (SPI Ethernet), ENC28J60 (SPI Ethernet), or ESP8266/ESP32 (WiFi via UART/SPI). The W5500 is recommended for ease of use as it handles the TCP/IP stack internally.');
INSERT INTO knowledge VALUES ('common_sensor_list', 'Sensors', '["sensor","module","common","popular","list"]', 'Common sensors compatible with STM32F103C8T6: I2C: MPU6050 (IMU), BMP280/BME280 (pressure/humidity), SSD1306 (OLED display), DS3231 (RTC), PCF8574 (GPIO expander). SPI: MAX31855 (thermocouple), MCP3008 (ADC), SD card, ILI9341 (TFT display), NRF24L01 (radio). UART: GPS modules, ESP8266, Bluetooth HC-05/06. Analog: photoresistors, thermistors, potentiometers. Digital: DHT11/22 (temperature/humidity), HC-SR04 (ultrasonic).');
